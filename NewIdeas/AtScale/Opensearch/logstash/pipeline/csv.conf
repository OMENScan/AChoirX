#############################
# INPUT
#############################
input {
  file {
    path => "/data/**/*.csv"
    mode => "read"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    file_completed_action => "delete"
    file_completed_log_path => "/usr/share/logstash/logs/completed.log"
  }
}

#############################
# FILTERS
#############################
filter {
  # Debug: keep original path for verification
  mutate { add_field => { "DEBUG_path" => "%{[log][file][path]}" } }

  # 1. Extract case-id, hostname, artifact filename
  grok {
    match => { "[log][file][path]" => ".*/data/(?<case_id>[^/]+)/(?<host_name>[^/]+)/(?<artifact_file>[^/]+\.csv)$" }
  }

  # 2. Defaults if parsing fails
  if ![case_id] or [case_id] == "" {
    mutate { replace => { "case_id" => "unknown" } }
  }

  if ![host_name] or [host_name] == "" {
    mutate { replace => { "host_name" => "unknown" } }
  }

  # 3. Normalize for OpenSearch index safety
  mutate { lowercase => ["case_id","host_name"] }

  # 4. Add fields for indexing
  mutate {
    add_field => {
      "[case][id]"        => "%{case_id}"
      "[host][name]"      => "%{host_name}"
      "[artifact][file]"  => "%{artifact_file}"
    }
  }

  # 5. Artifact-specific CSV parsing
  if [artifact_file] == "FLSOut.csv" {
    mutate { add_field => { "[artifact][type]" => "filelist" } }

    csv {
      separator => ","
      skip_header => true
      columns => ["fullpath","atime","mtime","ctime","size"]
      target => "filelist"
    }

    mutate { convert => { "[filelist][size]" => "integer" } }

  } else if [artifact_file] == "ts_Events_Logon.csv" {
    mutate { add_field => { "[artifact][type]" => "eventlog" } }

    csv {
      separator => ","
      skip_header => true
      columns => ["datetime","timestamp_desc","host","eventid","data","artifact","message"]
      target => "eventlog"
    }

  } else if [artifact_file] == "ts_arp_cache.csv" {
    mutate { add_field => { "[artifact][type]" => "arpcache" } }

    csv {
      separator => ","
      skip_header => true
      columns => ["datetime","timestamp_desc","src_mac","interface","artifact","message"]
      target => "arpcache"
    }

  } else if [artifact_file] == "ts_defender_services.csv" {
    mutate { add_field => { "[artifact][type]" => "windefender" } }

    csv {
      separator => ","
      skip_header => true
      columns => ["service_name","status","start_type","artifact","message"]
      target => "windefender"
    }

  } else if [artifact_file] == "ts_dns_cache.csv" {
    mutate { add_field => { "[artifact][type]" => "dnscache" } }

    csv {
      separator => ","
      skip_header => true
      columns => ["dns_name","artifact","message"]
      target => "dnscache"
    }

  } else if [artifact_file] == "ts_established_connections.csv" {
    mutate { add_field => { "[artifact][type]" => "estconnection" } }

    csv {
      separator => ","
      skip_header => true
      columns => ["pid","protocol","local_address","local_port","remote_address","remote_port","state","artifact","message"]
      target => "estconnection"
    }

  } else if [artifact_file] == "ts_downloaded_executables.csv" {
    mutate { add_field => { "[artifact][type]" => "downloaded" } }

    csv {
      separator => ","
      skip_header => true
      columns => ["datetime","timestamp_desc","path","size","artifact","message"]
      target => "downloaded"
    }

  } else if [artifact_file] == "ts_Events_AccountChanges.csv" {
    mutate { add_field => { "[artifact][type]" => "eventlog" } }

    csv {
      separator => ","
      skip_header => true
      columns => ["datetime","timestamp_desc","host","eventid","data","artifact","message"]
      target => "eventlog"
    }

  } else if [artifact_file] == "ts_Events_AuditPolicyChanged.csv" {
    mutate { add_field => { "[artifact][type]" => "eventlog" } }

    csv {
      separator => ","
      skip_header => true
      columns => ["datetime","timestamp_desc","host","eventid","data","artifact","message"]
      target => "eventlog"
    }

  } else if [artifact_file] == "ts_Events_AV_Detections.csv" {
    mutate { add_field => { "[artifact][type]" => "eventlog" } }

    csv {
      separator => ","
      skip_header => true
      columns => ["datetime","timestamp_desc","host","eventid","data","artifact","message"]
      target => "eventlog"
    }

  } else if [artifact_file] == "ts_Events_LogClearing.csv" {
    mutate { add_field => { "[artifact][type]" => "eventlog" } }

    csv {
      separator => ","
      skip_header => true
      columns => ["datetime","timestamp_desc","host","eventid","data","artifact","message"]
      target => "eventlog"
    }

  } else if [artifact_file] == "ts_Events_PermissionsChanged.csv" {
    mutate { add_field => { "[artifact][type]" => "eventlog" } }

    csv {
      separator => ","
      skip_header => true
      columns => ["datetime","timestamp_desc","host","eventid","data","artifact","message"]
      target => "eventlog"
    }

  } else if [artifact_file] == "ts_Events_PowerShell_4104.csv" {
    mutate { add_field => { "[artifact][type]" => "eventlog" } }

    csv {
      separator => ","
      skip_header => true
      columns => ["datetime","timestamp_desc","host","eventid","data","artifact","message"]
      target => "eventlog"
    }

  } else if [artifact_file] == "processes.csv" {
    mutate { add_field => { "[artifact][type]" => "processes" } }

    csv {
      separator => ","
      skip_header => true
      columns => ["process_name","pid","ppid","command_line"]
      target => "process"
    }

    mutate {
      convert => {
        "[process][pid]"  => "integer"
        "[process][ppid]" => "integer"
      }
    }

  } else if [artifact_file] == "network.csv" {
    mutate { add_field => { "[artifact][type]" => "network" } }

    csv {
      separator => ","
      skip_header => true
      columns => ["local_address","local_port","remote_address","remote_port","protocol","state"]
      target => "network"
    }

    mutate {
      convert => {
        "[network][local_port]"  => "integer"
        "[network][remote_port]" => "integer"
      }
    }

  } else if [artifact_file] == "ts_Events_ScheduledTasks.csv" {
    mutate { add_field => { "[artifact][type]" => "eventlog" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["datetime","timestamp_desc","host","eventid","data","artifact","message"]
      target => "eventlog"
    }

  } else if [artifact_file] == "ts_Events_ServiceInstall.csv" {
    mutate { add_field => { "[artifact][type]" => "eventlog" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["datetime","timestamp_desc","host","eventid","data","artifact","message"]
      target => "eventlog"
    }

  } else if [artifact_file] == "ts_Events_Sysmon_Process.csv" {
    mutate { add_field => { "[artifact][type]" => "sysmon_process" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["datetime","timestamp_desc","host","eventid","image","command_line","parent_image","artifact","message"]
      target => "sysmon_process"
    }

  } else if [artifact_file] == "ts_Events_Sysmon_Network.csv" {
    mutate { add_field => { "[artifact][type]" => "sysmon_network" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["datetime","timestamp_desc","host","eventid","image","source_ip","source_port","dest_ip","dest_port","protocol","artifact","message"]
      target => "sysmon_network"
    }

  } else if [artifact_file] == "ts_Events_Sysmon_LSASS.csv" {
    mutate { add_field => { "[artifact][type]" => "sysmon_lsass" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["datetime","timestamp_desc","host","eventid","image","target_image","artifact","message"]
      target => "sysmon_lsass"
    }

  } else if [artifact_file] == "ts_listening_ports.csv" {
    mutate { add_field => { "[artifact][type]" => "listening_ports" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["pid","port","protocol","address","process","artifact","message"]
      target => "listening_ports"
    }

  } else if [artifact_file] == "ts_logged_in_users.csv" {
    mutate { add_field => { "[artifact][type]" => "loggedin_users" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["user","tty","host","time","artifact","message"]
      target => "loggedin_users"
    }

  } else if [artifact_file] == "ts_os_version.csv" {
    mutate { add_field => { "[artifact][type]" => "os_version" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["name","version","major","minor","build","platform","artifact","message"]
      target => "os_version"
    }

  } else if [artifact_file] == "ts_pipes.csv" {
    mutate { add_field => { "[artifact][type]" => "named_pipes" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["name","instances","max_instances","artifact","message"]
      target => "pipes"
    }

  } else if [artifact_file] == "ts_prefetch.csv" {
    mutate { add_field => { "[artifact][type]" => "prefetch" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["path","last_run_time","run_count","artifact","message"]
      target => "prefetch"
    }

  } else if [artifact_file] == "ts_processes.csv" {
    mutate { add_field => { "[artifact][type]" => "processes_osq" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["datetime","timestamp_desc","pid","ppid","process_name","process_path","cmdline","artifact","message"]
      target => "processes_osq"
    }

  } else if [artifact_file] == "ts_recent_files.csv" {
    mutate { add_field => { "[artifact][type]" => "recent_files" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["path","last_opened","artifact","message"]
      target => "recent_files"
    }

  } else if [artifact_file] == "ts_registry_run_keys.csv" {
    mutate { add_field => { "[artifact][type]" => "registry_run" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["key","name","value","artifact","message"]
      target => "registry_run"
    }

  } else if [artifact_file] == "ts_scheduled_tasks.csv" {
    mutate { add_field => { "[artifact][type]" => "scheduled_tasks" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["name","path","state","action","artifact","message"]
      target => "scheduled_tasks"
    }

  } else if [artifact_file] == "ts_services.csv" {
    mutate { add_field => { "[artifact][type]" => "services" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["name","display_name","status","start_type","path","artifact","message"]
      target => "services"
    }

  } else if [artifact_file] == "ts_shellbags.csv" {
    mutate { add_field => { "[artifact][type]" => "shellbags" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["path","mtime","artifact","message"]
      target => "shellbags"
    }

  } else if [artifact_file] == "ts_shimcache.csv" {
    mutate { add_field => { "[artifact][type]" => "shimcache" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["path","last_modified","artifact","message"]
      target => "shimcache"
    }

  } else if [artifact_file] == "ts_startup_folder.csv" {
    mutate { add_field => { "[artifact][type]" => "startup_folder" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["path","artifact","message"]
      target => "startup_folder"
    }

  } else if [artifact_file] == "ts_suspicious_cmdlines.csv" {
    mutate { add_field => { "[artifact][type]" => "suspicious_cmdline" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["pid","cmdline","artifact","message"]
      target => "suspicious_cmdline"
    }

  } else if [artifact_file] == "ts_system_boot.csv" {
    mutate { add_field => { "[artifact][type]" => "system_boot" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["boot_time","artifact","message"]
      target => "system_boot"
    }

  } else if [artifact_file] == "ts_system_identity.csv" {
    mutate { add_field => { "[artifact][type]" => "system_identity" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["hostname","domain","uuid","artifact","message"]
      target => "system_identity"
    }

  } else if [artifact_file] == "ts_userassist.csv" {
    mutate { add_field => { "[artifact][type]" => "userassist" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["path","execution_count","last_execution","artifact","message"]
      target => "userassist"
    }

  } else if [artifact_file] == "ts_users.csv" {
    mutate { add_field => { "[artifact][type]" => "users" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["username","uid","gid","directory","shell","artifact","message"]
      target => "users"
    }

  } else if [artifact_file] == "ts_wmi_event_filters.csv" {
    mutate { add_field => { "[artifact][type]" => "wmi_persistence" } }
    csv {
      separator => ","
      skip_header => true
      columns => ["name","query","namespace","artifact","message"]
      target => "wmi_persistence"
    }

  } else if [artifact_file] == "SchedTask.csv" {
    mutate { add_field => { "[artifact][type]" => "schedtsk" } }
    csv {
      separator => ","
      skip_header => false
      columns => ["sched_host","sched_path","sched_time1","sched_stat","sched_forg","sched_time2","sched_num","sched_authr","sched_cmd","sched_actor","sched_desc","sched_enable1","sched_enable2","sched_crit","sched_user","sched_enable3","sched_timer1","sched_data","sched_when","sched_time3","sched_date","sched_x","sched_freq1","sched_freq2","sched_timer2","sched_enable4","sched_timer3","sched_enable5"]
      target => "schedtsk"
    }

  } else if [artifact_file] == "ASEP-All.csv" {
    mutate { add_field => { "[artifact][type]" => "asep" } }
    csv {
      separator => "\t"
      skip_header => false
      columns => ["asep_type","asep_subtype","asep_location","asep_cmd"]
      target => "asep"
    }

  } else {
    # Catch-all CSV parser for unknown artifacts
    mutate { add_field => { "[artifact][type]" => "unknown" } }
  }
}

#############################
# OUTPUT
#############################
output {
  if [case_id] != "unknown" and [host_name] != "unknown" {
    opensearch {
      hosts => ["http://opensearch-dfir:9200"]
      index => "dfir-%{case_id}-%{host_name}"
      user => "admin"
      password => "admin"
      ssl => false
    }
  } else {
    stdout { codec => rubydebug }  # For debugging unknowns
  }
}

